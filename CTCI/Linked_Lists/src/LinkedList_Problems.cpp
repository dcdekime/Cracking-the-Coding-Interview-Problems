#include "LinkedList_Problems.h"

LinkedListProblems::LinkedListProblems() {};

/*  Problem Source: Cracking the Coding Interview - 2.1 Remove Dups

    Problem Description: Write code to remove duplicates from an unsorted linked list
                         FOLLOW UP: How would you solve this problem if a temporary buffer
                                    is not allowed?

    Approach:
        1)
 
     
     Time Complexity:    O()
     Space Complexity:   O()
*/

void LinkedListProblems::removeDups(Node *root)
{
    
}


/*  Problem Source: Cracking the Coding Interview - 2.2 Return Kth to Last

    Problem Description: Implement an algorithm to find the kth to last element of a singly linked list

    Approach:
        1)
 
     
     Time Complexity:    O()
     Space Complexity:   O()
*/

Node* LinkedListProblems::returnKthToLast(Node *root)
{
    return nullptr;
}


/*  Problem Source: Cracking the Coding Interview - 2.3 Delete Middle Node

    Problem Description: Implement an algorithm to delete a node in the middle.
                         (i.e. any node but the first and last node, not necessarily the exacty middle)
                         of a singly linked list, given only access to that node.
    
    EXAMPLE:
        Input: the node c from the linked list a -> b -> c -> d -> e -> f
        Output: nothing is returned, but the new linked list looks like a -> b -> d -> e -> f

    Approach:
        1)
 
     
     Time Complexity:    O()
     Space Complexity:   O()
*/

void LinkedListProblems::deleteMiddleNode(Node *root)
{
    
}


/*  Problem Source: Cracking the Coding Interview - 2.4 Partition

    Problem Description: Write code to partition a linked list around a value X, such that all nodes
                         less than X come before all nodes greater than or equal to X. If X is contained
                         within the list, the values of X only need to be after the elements less than X
                         (see below). The partition element X can appear anywhere in the "right partition"
                         it does not need to appear between the left and right partitions.
    
    EXAMPLE:
        Input: 3 -> 5 -> 8 -> 5 -> 10 -> 2 -> 1 (partition = 5)
        Output: 3 -> 1 -> 2 -> 10 -> 5 -> 5 -> 8

    Approach:
        1)
 
     
     Time Complexity:    O()
     Space Complexity:   O()
*/

void LinkedListProblems::partition(Node* root, int X)
{
    
}


/*  Problem Source: Cracking the Coding Interview - 2.5 Sum Lists

    Problem Description: You have two numbers represented by linked lists, where each node contains a
                         single digit. The digits are stored in reverse order, such that the 1's digit
                         is at the head of the list. Write a function that adds the two numbers and
                         returns the suj as a linked list.
    
    EXAMPLE:
        Input: (7 -> 1 -> 6) + (5 -> 9 -> 2) That is, 617 + 295
        Output: 2 -> 1 -> 9 That is, 912

    Approach:
        1)
 
     
     Time Complexity:    O()
     Space Complexity:   O()
*/

Node* LinkedListProblems::sumLists(Node *root1, Node *root2)
{
    return nullptr;
}


/*  Problem Source: Cracking the Coding Interview - 2.6 Palindrome

    Problem Description: Implement a function to check if a linked list is a palindome

    Approach:
        1)
 
     
     Time Complexity:    O()
     Space Complexity:   O()
*/

bool LinkedListProblems::palindrome(Node *root)
{
    return true;
}


/*  Problem Source: Cracking the Coding Interview - 2.7 Intersection

    Problem Description: Given two singly linked lists, determine if the two lists intersect. Return the
                         intersecting node. Note that the intersection is defined based on reference, not
                         value. That is, if the kth node of the first linked list is the exact same node
                         (by reference) as the jth node of the second linked list, then they are
                         intersecting.

    Approach:
        1)
 
     
     Time Complexity:    O()
     Space Complexity:   O()
*/

bool LinkedListProblems::intersection(Node *root1, Node *root2)
{
    return true;
}


/*  Problem Source: Cracking the Coding Interview - 2.8 Loop Detection
 
    Problem Description: Given a circular linked list, implement an algorithm that returns the node at the
                         beginning of the loop.
 
    DEFINITION: A circular linked list is a (corrupt) linked list in which a node's next pointer points to
                an earlier node, so as to make a loop in the linked list.
    
    EXAMPLE:
        Input: A -> B -> C -> D -> E -> C (the same C as earlier)
        Output: C

    Approach:
        1)
 
     
     Time Complexity:    O()
     Space Complexity:   O()
*/

Node* LinkedListProblems::loopDetection(Node *root)
{
    return nullptr;
}





    
